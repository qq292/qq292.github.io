<!DOCTYPE html>
<html lang="zh-cn">
<!-- https://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript+abap+abnf+actionscript+ada+agda+al+antlr4+apacheconf+apex+apl+applescript+aql+arduino+arff+armasm+arturo+asciidoc+aspnet+asm6502+asmatmel+autohotkey+autoit+avisynth+avro-idl+awk+bash+basic+batch+bbcode+bbj+bicep+birb+bison+bnf+bqn+brainfuck+brightscript+bro+bsl+c+csharp+cpp+cfscript+chaiscript+cil+cilkc+cilkcpp+clojure+cmake+cobol+coffeescript+concurnas+csp+cooklang+coq+crystal+css-extras+csv+cue+cypher+d+dart+dataweave+dax+dhall+diff+django+dns-zone-file+docker+dot+ebnf+editorconfig+eiffel+ejs+elixir+elm+etlua+erb+erlang+excel-formula+fsharp+factor+false+firestore-security-rules+flow+fortran+ftl+gml+gap+gcode+gdscript+gedcom+gettext+gherkin+git+glsl+gn+linker-script+go+go-module+gradle+graphql+groovy+haml+handlebars+haskell+haxe+hcl+hlsl+hoon+http+hpkp+hsts+ichigojam+icon+icu-message-format+idris+ignore+inform7+ini+io+j+java+javadoc+javadoclike+javastacktrace+jexl+jolie+jq+jsdoc+js-extras+json+json5+jsonp+jsstacktrace+js-templates+julia+keepalived+keyman+kotlin+kumir+kusto+latex+latte+less+lilypond+liquid+lisp+livescript+llvm+log+lolcode+lua+magma+makefile+markdown+markup-templating+mata+matlab+maxscript+mel+mermaid+metafont+mizar+mongodb+monkey+moonscript+n1ql+n4js+nand2tetris-hdl+naniscript+nasm+neon+nevod+nginx+nim+nix+nsis+objectivec+ocaml+odin+opencl+openqasm+oz+parigp+parser+pascal+pascaligo+psl+pcaxis+peoplecode+perl+php+phpdoc+php-extras+plant-uml+plsql+powerquery+powershell+processing+prolog+promql+properties+protobuf+pug+puppet+pure+purebasic+purescript+python+qsharp+q+qml+qore+r+racket+cshtml+jsx+tsx+reason+regex+rego+renpy+rescript+rest+rip+roboconf+robotframework+ruby+rust+sas+sass+scss+scala+scheme+shell-session+smali+smalltalk+smarty+sml+solidity+solution-file+soy+sparql+splunk-spl+sqf+sql+squirrel+stan+stata+iecst+stylus+supercollider+swift+systemd+t4-templating+t4-cs+t4-vb+tap+tcl+tt2+textile+toml+tremor+turtle+twig+typescript+typoscript+unrealscript+uorazor+uri+v+vala+vbnet+velocity+verilog+vhdl+vim+visual-basic+warpscript+wasm+web-idl+wgsl+wiki+wolfram+wren+xeora+xml-doc+xojo+xquery+yaml+yang+zig&plugins=line-highlight+line-numbers+show-language+normalize-whitespace+data-uri-highlight+toolbar+copy-to-clipboard -->

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="source/css/all.css">
    <link href="source/css/prism.css" rel="stylesheet" />
    <script src="source/js/prism.js"></script>
    <title>Behavior Designer(中文)</title>

</head>
<style>
    * {
        padding: 0px;
        margin: 0px;
        box-sizing: border-box;
    }

    ul,

    .scroll::-webkit-scrollbar {
        width: 2px;
    }

    .scroll::-webkit-scrollbar-thumb {
        background-image: var(--linear-001);
        border-radius: 5px;

    }

    :root {
        --tool-height: 40px;
        --h1-height: 42px;
        --catalog-width: 340px;
        --anim-catalog-width: calc(-1 * var(--catalog-width));
        --linear-001: linear-gradient(45deg, white 0%, deeppink 40%, skyblue 60%, white 100%);
        font-size: medium;
        --green-01: #3da33d;

    }

    ul {
        list-style: none;
        width: 100%;
    }



    .red {
        background-color: red;
    }

    .green {
        background-color: green;
    }

    .pink {
        background-color: pink;
    }

    .gray {
        background-color: gray;
    }

    .scroll {
        overflow-y: auto;
        overflow-x: hidden;
    }

    body {
        height: auto;
    }

    .container {
        width: 100%;
        height: calc(100vh - var(--tool-height));
        display: flex;
        flex-wrap: wrap;


    }

    .catalog li a {
        display: inline-block;
        text-decoration: none;
        color: black;
        width: 100%;
        height: 100%;
        padding: 10px 10px 10px 40px;
        font-size: small;

    }

    .catalog li:hover a {
        color: var(--green-01);
    }

    .catalog li:hover {
        background-color: #20252329;

    }

    .catalog ul {
        padding: 10px 8px;
    }

    .catalog li {
        border-radius: 4px;
        cursor: pointer;
        width: 100%;
        text-align: left;

    }

    .content h1 {
        line-height: var(--h1-height);
        padding: 10px 0px;
        top: 0px;
        background-color: white;
    }

    .content p {
        white-space: pre-line;

        padding-bottom: 3rem;
    }


    .content img {
        padding: 20px 0px;
    }



    .content-box {
        display: flex;
        width: 100%;
        height: 100%;
        position: relative;
        background-color: #e6e6e6;

    }

    .active a {
        color: var(--green-01) !important;
    }

    .catalog {
        background-color: white;
        height: 100%;
        width: var(--catalog-width);
        display: flex;
        justify-content: center;
        border-right: 1px solid gray;
        position: absolute;
        top: 0;
        z-index: 1000;
    }

    .scroll-smooth {
        scroll-behavior: smooth;
    }

    .content-article {
        display: flex;
        justify-content: center;
        width: 100%;
        height: 100%;

    }

    .content {
        background-color: white;
        height: 100%;
        width: 50%;
        display: flex;
        flex-direction: column;
        padding: 0px 3.2rem;
        box-shadow: 0 0 2px gray;
        font-size: medium;
        line-height: 1.8rem;

    }

    .content ul {
        list-style: inside;
    }

    .content li {
        /* line-height: 1em; */
        padding-left: 10px;
        padding-top: 4px;
        padding-bottom: 4px;
        display: inline-block;

    }

    img {
        max-width: 100%;
        /* 图片的最大宽度为父容器的100% */
        height: auto;
        /* 高度根据宽度自动缩放，保持宽高比 */
    }

    .hide {
        display: none;
    }



    .toolBar {
        display: flex;
        width: 100%;
        height: var(--tool-height);
        border-bottom: 1px solid gray;
        /* position: sticky; */
        top: 0px;
        bottom: 100%;
        background-color: transparent;
        padding: 0px 10px;
        background-color: #f7f7f7;
        z-index: 1000;

    }

    .toolBar-left,
    .toolBar-right,
    .toolBar-center {
        display: flex;
        align-items: center;
        width: 100%;
        height: 100%;
    }

    .anim-catalog-to,
    .anim-catalog-back {
        animation-duration: 0.15s;
        animation-fill-mode: forwards;
        animation-name: catalog-to;
    }

    .anim-catalog-back {
        animation-direction: reverse;
    }

    #menu {
        cursor: pointer;
        padding: 0.4rem;
        border-radius: 10%;
    }

    #menu:hover {
        background-color: rgba(111, 111, 111, 0.24);
    }

    @keyframes catalog-to {
        0% {
            transform: translateX(0px);
        }

        100% {
            transform: translateX(var(--anim-catalog-width));
        }
    }

    .toolBar-right-group1 {
        width: 100%;
        display: flex;
        justify-content: flex-end;
    }

    #lang-select {
        display: flex;
        outline: none;
        height: 1.5rem;
        padding: 0px 6px;

    }

    #lang-select:hover {
        background-image: var(--linear-001);
        color: transparent;
        background-clip: text;
    }

    @media (max-width: 2400px) {
        .content {
            height: 100%;
            width: 50%;
            padding: 0px 3.2rem;
        }

    }

    @media (max-width: 1199px) {
        .content {
            height: 100%;
            width: 80%;
            padding: 0px 2.2rem;
        }

    }

    @media(max-width: 575px) {
        .content {
            height: 100%;
            width: 100%;
            padding: 0px 1.2rem;
        }

        .catalog {
            width: 100%;
        }

        @keyframes catalog-to {
            0% {
                transform: translateX(0%);
            }

            100% {
                transform: translateX(-100%);
            }
        }
    }
</style>

<body>
    <div class="toolBar">
        <div class="toolBar-left ">
            <i id="menu" class="fa fa-align-right" style="font-size:1.15rem;"></i>
        </div>
        <div class="toolBar-center ">
            <!-- <button>setting</button> -->
        </div>
        <div class="toolBar-right ">
            <div class="toolBar-right-group1">
                <select name="select" id="lang-select">
                    <option value="中文">中文</option>
                    <option value="英语">英语</option>
                    <option value="日语">日语</option>
                </select>
            </div>
        </div>

    </div>
    <div class="container ">


        <div class="content-box">
            <div class="catalog scroll">
                <ul>
                </ul>
            </div>
            <div class="content-article">
                <div class="content scroll scroll-smooth">

                </div>
            </div>
        </div>
    </div>
</body>
<script>
    const datas = [
        {
            title: "概述",
            content: `
                行为设计器（Behavior Designer）是一个为所有人设计的行为树实现，包括程序员、美术师和设计师。
                行为设计器提供强大的 API，让你能够轻松创建新任务。它还提供一个直观的可视化编辑器，并与广泛的第三方集成，从而可以在无需编写一行代码的情况下创建复杂的 AI。
                本指南将对行为设计器的各个方面进行总体概述。如果你刚开始接触行为树，我们有一个“行为树基础”视频系列。本页也提供了行为树的快速概述。使用行为设计器时，你无需了解底层行为树的实现，但了解一些关键概念（如任务类型：动作、组合、条件和装饰器）是一个好主意。
                当你第一次打开行为设计器时，你将看到以下窗口：
                <img src="source/images/s001.png">
                行为设计器 (Behavior Designer) 中有四个部分。从下面的截图中可以看到，第一部分是图表区域。你将在那里创建行为树。第二部分是属性面板。
                你将在属性面板中编辑行为树的特定属性、添加新任务、创建新变量或编辑任务的参数。第三部分是行为树操作工具栏。你可以使用下拉框选择现有的行为树或添加/移除行为树。
                最后一部分，第四部分，是调试工具栏。你可以在此面板中启动/停止、步进和暂停 Unity。此外，你还可以看到你的树拥有的错误数量，甚至在开始执行你的树之前。
                <img src="source/images/s002.png">
                第一部分 是行为设计器（Behavior Designer）的主要工作区域。在这个区域内，你可以创建新的任务，并将这些任务排列成行为树。首先，你需要添加一个行为树组件。行为树组件将充当你正在创建的行为树的管理器。你可以通过以下两种方式创建一个新的行为树组件：在图形区域内右键单击并选择“添加行为树”，或者点击第三部分操作区域中“锁定”旁边的加号按钮。

                添加行为树后，您可以开始添加任务。通过在图形区域中右键单击或单击属性面板第 2 部分中的“Tasks”选项卡来添加任务。也可以通过按空格键并打开快速任务搜索窗口来添加新任务：
                <img src="source/images/s003.png">
                添加任务后，您将看到以下内容：
                <img src="source/images/s004.png">
                除了您添加的任务之外，还会添加入口任务。入口任务充当树的根。这是 entry 任务的唯一目的。序列任务出错，因为它没有子项。添加子项后，错误就会消失。现在我们已经添加了第一个任务，让我们再添加一些任务：
                <img src="source/images/s005.png">
                你可以通过从序列任务的底部拖动到选择器任务的顶部来连接序列任务和选择器任务。对剩余的任务重复此过程。 如果你犯了错误，可以选择连接线并使用删除键将其删除。你还可以通过单击任务并拖动它来重新排列任务。

                行为设计器将按照深度优先的顺序执行任务。你可以通过将任务拖动到其同级任务的左侧/右侧来更改任务的执行顺序。从上面的屏幕截图来看，任务将按照以下顺序执行：

                SequenceA, SelectorA, SequenceB, ActionA, ActionB, ActionC, SelectorB, ActionD, ActionE
                <img src="source/images/s006.png">
                现在我们已经创建了一个基本行为树，让我们修改其中一个任务的参数。选择 ActionC 节点以在属性面板中调出 Inspector。您可以在此处看到，我们可以重命名任务、将任务设置为即时任务或输入任务注释。此外，我们可以修改 task 类包含的所有公共变量。这包括分配在 Behavior Designer 中创建的变量。在我们的例子中，唯一的公共变量是 Rotation Speed。我们将参数设置为的值将在行为树中使用。

                属性面板中还有其他三个选项卡：Variables、Tasks 和 Behavior。变量面板允许您创建在任务之间共享的变量。有关更多信息，请查看 <a href="https://opsive.com/support/documentation/behavior-designer/variables/"> variables </a>主题。tasks （任务） 面板列出了您可以使用的所有可能任务。此列表与右键单击并添加任务时找到的列表相同。此列表是通过搜索从 action、composite、conditional 或 decorator 任务类型派生的任何类来创建的。最后一个面板（行为面板）显示您在首次创建行为树时添加的 Behavior Tree （行为树） 组件的检查器。有关每个选项的作用的更多详细信息，请参阅  <a href="https://opsive.com/support/documentation/behavior-designer/behavior-tree-component/"> Behavior Component Overview </a>（行为组件概述） 页面。
                <img src="source/images/s007.png">
                Behavior Designer （行为设计器） 窗口中的最后一部分是 operations （作） 工具栏。作工具栏主要用于选择行为树以及添加/删除行为树。标记了以下作：
                <ul>
                    <li>标签 1：在您打开的行为树之间向后/向前导航</li>
                    <li>标签 2：列出场景或项目（包括预制件）中的所有行为树。</li>
                    <li>标签 3：列出场景中添加了行为树组件的任何游戏对象。</li>
                    <li>标签 4：列出附加到从标签 3 中选择的游戏对象的任何行为树。</li>
                    <li>标签 5：列出当前行为树引用的任何外部行为树</li>
                    <li>标签 6: 移除当前选定的行为树</li>
                    <li>标签 7：向游戏对象添加新的行为树。</li>
                    <li>标签 8：保持当前行为树处于活动状态，即使您在层次结构或项目窗口中选择了不同的游戏对象</li>
                    <li>标签 9：将行为树导出到外部行为树资源。</li>
                    <li>标签 10：打开可以搜索您的行为树的 find 对话框</li>
                    <li>标签 11：截取当前行为树的屏幕截图</li>
                    <li>标签 12：显示 Behavior Designer 首选项。</li>
                </ul>

            `
        }
        , {
            title: "什么是行为树？",
            content: `
            行为树是许多游戏中常用的一种 AI 技术。Halo 2 是第一款使用行为树的主流游戏，在发布了如何在 Halo 2 中使用行为树的详<a href="http://www.gamasutra.com/view/feature/130663/gdc_2005_proceeding_handling_.php">细说明后</a>，它们开始变得更加流行。行为树是许多不同 AI 技术的组合：分层状态机、调度、规划和作执行。它们的主要优点之一是它们易于理解，并且可以使用可视化编辑器创建.
            <img src="source/images/s008.png">
            在最简单的级别上，行为树是任务的集合。有四种不同类型的任务：作、条件、复合和装饰器。动作任务可能是最容易理解的，因为它们以某种方式改变了游戏的状态。条件任务测试游戏的某些属性。例如，在上面的树中，AI 代理有两个条件任务和两个作任务。前两个条件任务检查代理的视线范围内是否有敌人，然后确保代理有足够的子弹来发射他的武器。如果这两个条件都成立，则将运行两个作任务。其中一个作任务射击武器，另一个任务播放射击动画。当您形成不同的子树时，行为树的真正力量就会发挥作用。这两个射击动作可以形成一个子树。如果前面的条件任务之一失败，则可以创建另一个子树，该子树执行一组不同的作任务，例如逃离敌人。您可以将子树彼此组合在一起，以形成高级行为。

            复合任务是包含子任务列表的父任务。在上面的示例中，复合任务被标记为 sequence 和 parallel。序列任务将每个任务运行一次，直到所有任务都已运行完毕。它首先运行条件任务，检查是否有敌人在视线范围内。如果敌人在视线范围内，它将运行条件任务，检查代理是否还有子弹。如果代理有足够的子弹，则将运行并行任务，以射击武器并播放射击动画。序列任务一次执行一个子任务，而并行任务同时执行其所有子任务。

            最后一种任务类型是装饰器任务。装饰器任务是一个父任务，它只能有一个子任务。它的功能是以某种方式修改子任务的行为。在上面的例子中，我们没有使用装饰器任务，但如果你想阻止一个任务过早运行（称为中断任务），你可能需要使用它。例如，一个代理可能正在执行诸如收集资源之类的任务。然后，它可以有一个中断任务，如果附近有敌人，就会停止收集资源。另一个装饰器任务的例子是，它会重复运行其子任务x次，或者一个装饰器任务会一直运行子任务，直到它成功完成。

            到目前为止，我们遗漏的主要行为树主题之一是任务的返回状态。您可能有一个任务需要多个帧才能完成。例如，大多数动画不会在一帧内开始和结束。此外，条件任务需要一种方法来告诉其父任务条件是否为 true，以便父任务可以决定是否应继续运行其子任务。这两个问题都可以使用 task status 来解决。任务处于以下三种不同状态之一：正在运行、成功或失败。在第一个示例中，只要拍摄动画正在播放，拍摄动画任务的任务状态就为 running。确定敌人是否在视线范围内的条件任务将在一帧内返回成功或失败。

            Behavior Designer 采用所有这些概念，并将其打包在一个易于使用的界面中，并使用类似于 Unity 的 MonoBehaviour API 的 API。Behavior Designer 在标准安装中包含许多 composite 和 decorator 类。动作和条件任务更特定于游戏，因此包含的任务不多，但<a href="https://opsive.com/integrations/?pid=803">示例项目</a>中有许多示例。可以通过从其中一个任务类型<a href="https://opsive.com/support/documentation/behavior-designer/writing-a-new-conditional-task/">扩展</a>来创建新任务。此外，还制作了许多<a href="https://opsive.com/support/documentation/behavior-designer/videos/">视频</a>，以尽可能轻松地学习 Behavior Designer。  

            `
        },
        {
            title: "行为树或有限状态机行为树或有限状态机行为树或有限状态机",
            content: `
            在什么情况下，您会在有限状态机（例如 Playmaker）上使用行为树？在最高级别，行为树用于 AI，而有限状态机 （FSM） 用于更通用的可视化编程。虽然您可以将行为树用于一般的可视化编程，将有限状态机用于 AI，但这并不是每个工具的设计目的。根据一些人的说法，<a href="http://aigamedev.com/open/article/fsm-age-is-over/">有限状态机</a>的时代已经结束。我们不会走那么远，但在 AI 方面，行为树肯定比有限状态机有其优势。

            与 FSM 相比，行为树有一些优点：它们提供了很大的灵活性，非常强大，并且真的很容易进行更改。

            让我们首先看一下第一个优势：灵活性。使用 FSM，您如何同时运行两个不同的状态？唯一的方法是创建两个单独的 FSM。使用行为树，您需要做的就是添加并行任务，然后就完成了 – 所有子任务都将并行运行。使用行为设计器，这些子任务可以是 PlayMaker FSM，并且这些 FSM 将并行运行。

            灵活性的另一个示例是 Task Guard 任务。在此示例中，您有两个不同的任务来播放声音效果。这两个不同的任务位于行为树的两个不同分支中，因此它们彼此不了解，并且可能会同时播放声音效果。你不希望这种情况发生，因为它听起来不太好。在这种情况下，您可以添加一个信号量任务（在 Behavior Designer 中称为 Task Guard），它一次只允许播放一个音效。当第一个声音播放完毕时，第二个声音将开始播放。

            行为树的另一个优点是它们功能强大。这并不是说有限状态机不强大，只是它们在不同的方面强大。我们认为，与有限状态机相比，行为树使你的人工智能更容易对当前游戏状态做出反应。创建一个能够对各种情况做出反应的行为树更容易，而要使用有限状态机实现类似的人工智能，则需要大量的状态和转换。为了用有限状态机达到相同的结果，你最终会得到一个“<a href="https://answers.unrealengine.com/storage/temp/23368-statemachinespaghetti.png">意大利面条式</a>”的状态机。

            行为树的最后一个优点是它们真的很容易进行更改。行为树如此受欢迎的原因之一是因为它们很容易使用可视化编辑器创建。如果要使用 FSM 更改状态执行顺序，则必须更改状态之间的转换。使用行为树，您只需拖动任务即可。您不必担心过渡。此外，只需更改任务或向任务分支添加新的父任务，即可完全改变 AI 对不同情况的反应方式，这真的很容易。

            话虽如此，行为树和 FSM 不必是互斥的。行为树可以描述 AI 的流程，而 FSM 可以描述函数。这种组合为您提供了行为树的强大功能，同时仍然具有 FSM 的功能。
            `

        }, {
            title: "安装",
            content: `
            导入 Behavior Designer 后，您可以从 Tools （工具） 工具栏访问它。您可以通过导入位于 <a href="https://opsive.com/downloads/?pid=803">Downloads</a> 页面上的 Runtime Source Code 包来访问运行时源代码。<strong>在解压此包之前，请确保已删除 Behavior Designer 文件夹，否则将出现编译错误。</strong>

            为了编译通用 Windows 平台 （UWP） 的行为设计器，您必须使用运行时源代码而不是编译的 DLL。无需更改编译设置 – 行为设计器可以在启用 .Net Core 的情况下进行编译。

            当您尝试运行 UWP 应用程序时，可能会收到一个错误，指示找不到任务。为了解决这个问题，TaskUtility.GetTypesWithinAssembly（在 TaskUtility.cs 中）中的以下行应从：
            <pre><code class="language-csharp  line-numbers">
loadedAssemblies = GetStorageFileAssemblies(typeName).Result;
            </code></pre>


            
            `
        }
    ]
</script>
<script>

    let catalog_ul = document.querySelector(".catalog ul")
    let catalog = document.querySelector(".catalog")
    let content = document.querySelector(".content")
    let btn_menu = document.querySelector("#menu")


    console.log(JSON.stringify(datas))
    btn_menu.addEventListener("click", () => {
        if (catalog.classList.contains("anim-catalog-to")) {


            catalog.classList.remove("anim-catalog-to", "anim-catalog-back")
            void catalog.offsetWidth;  // 触发 reflow，强制浏览器重绘
            catalog.classList.add("anim-catalog-back")
        } else {

            catalog.classList.remove("anim-catalog-to", "anim-catalog-back")
            void catalog.offsetWidth;  // 触发 reflow，强制浏览器重绘
            catalog.classList.add("anim-catalog-to")
        }
    })



    function getAnchoor() {
        return document.querySelectorAll("*[id^='anchor']")
    }

    function generateLeftCatalog(anchors) {
        for (let anchor of anchors) {
            let li = document.createElement("li")
            let a = document.createElement("a")
            a.textContent = anchor.dataset.anchorTitle
            a.href = "#" + anchor.id
            li.appendChild(a)
            catalog_ul.appendChild(li)
        }
    }

    function generateContent(data) {
        let anchors = []
        for (let [i, data] of data.entries()) {
            let p = document.createElement("p")
            let h1 = document.createElement("h1")
            let span = document.createElement("span")
            anchors.push(span)
            span.setAttribute("data-anchor-title", data.title)
            span.id = "#anchor" + i
            h1.textContent = data.title
            p.innerHTML = data.content
            content.appendChild(span)
            content.appendChild(h1)
            content.appendChild(p)
        }
        return anchors

    }

    function readData(callBack) {
        fetch('data/BehaviorTreeDocument.json') // 'data.json' 是 JSON 文件相对于 index.html 的路径
            .then(response => response.json())
            .then(data => {
                // 在这里处理 JSON 数据
                callBack(data); // 例如，将数据打印到控制台
                // displayData(data); // 调用函数来显示数据
            })
            .catch(error => {
                console.error('Error fetching data:', error);
                document.getElementById('data-container').textContent = 'Failed to load data.'; // 显示错误信息
            });



    }

    readData((data)=>{
        console.log(data)
        let anchors = generateContent(data)
        generateLeftCatalog(anchors)
    })
    // let anchors = getAnchoor()
    


</script>

</html>
