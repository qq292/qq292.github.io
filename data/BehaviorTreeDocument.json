[
    {
        "title": "概述",
        "content": "\n                行为设计器（Behavior Designer）是一个为所有人设计的行为树实现，包括程序员、美术师和设计师。\n                行为设计器提供强大的 API，让你能够轻松创建新任务。它还提供一个直观的可视化编辑器，并与广泛的第三方集成，从而可以在无需编写一行代码的情况下创建复杂的 AI。\n                本指南将对行为设计器的各个方面进行总体概述。如果你刚开始接触行为树，我们有一个“行为树基础”视频系列。本页也提供了行为树的快速概述。使用行为设计器时，你无需了解底层行为树的实现，但了解一些关键概念（如任务类型：动作、组合、条件和装饰器）是一个好主意。\n                当你第一次打开行为设计器时，你将看到以下窗口：\n                <img src=\"source/images/s001.png\">\n                行为设计器 (Behavior Designer) 中有四个部分。从下面的截图中可以看到，第一部分是图表区域。你将在那里创建行为树。第二部分是属性面板。\n                你将在属性面板中编辑行为树的特定属性、添加新任务、创建新变量或编辑任务的参数。第三部分是行为树操作工具栏。你可以使用下拉框选择现有的行为树或添加/移除行为树。\n                最后一部分，第四部分，是调试工具栏。你可以在此面板中启动/停止、步进和暂停 Unity。此外，你还可以看到你的树拥有的错误数量，甚至在开始执行你的树之前。\n                <img src=\"source/images/s002.png\">\n                第一部分 是行为设计器（Behavior Designer）的主要工作区域。在这个区域内，你可以创建新的任务，并将这些任务排列成行为树。首先，你需要添加一个行为树组件。行为树组件将充当你正在创建的行为树的管理器。你可以通过以下两种方式创建一个新的行为树组件：在图形区域内右键单击并选择“添加行为树”，或者点击第三部分操作区域中“锁定”旁边的加号按钮。\n\n                添加行为树后，您可以开始添加任务。通过在图形区域中右键单击或单击属性面板第 2 部分中的“Tasks”选项卡来添加任务。也可以通过按空格键并打开快速任务搜索窗口来添加新任务：\n                <img src=\"source/images/s003.png\">\n                添加任务后，您将看到以下内容：\n                <img src=\"source/images/s004.png\">\n                除了您添加的任务之外，还会添加入口任务。入口任务充当树的根。这是 entry 任务的唯一目的。序列任务出错，因为它没有子项。添加子项后，错误就会消失。现在我们已经添加了第一个任务，让我们再添加一些任务：\n                <img src=\"source/images/s005.png\">\n                你可以通过从序列任务的底部拖动到选择器任务的顶部来连接序列任务和选择器任务。对剩余的任务重复此过程。 如果你犯了错误，可以选择连接线并使用删除键将其删除。你还可以通过单击任务并拖动它来重新排列任务。\n\n                行为设计器将按照深度优先的顺序执行任务。你可以通过将任务拖动到其同级任务的左侧/右侧来更改任务的执行顺序。从上面的屏幕截图来看，任务将按照以下顺序执行：\n\n                SequenceA, SelectorA, SequenceB, ActionA, ActionB, ActionC, SelectorB, ActionD, ActionE\n                <img src=\"source/images/s006.png\">\n                现在我们已经创建了一个基本行为树，让我们修改其中一个任务的参数。选择 ActionC 节点以在属性面板中调出 Inspector。您可以在此处看到，我们可以重命名任务、将任务设置为即时任务或输入任务注释。此外，我们可以修改 task 类包含的所有公共变量。这包括分配在 Behavior Designer 中创建的变量。在我们的例子中，唯一的公共变量是 Rotation Speed。我们将参数设置为的值将在行为树中使用。\n\n                属性面板中还有其他三个选项卡：Variables、Tasks 和 Behavior。变量面板允许您创建在任务之间共享的变量。有关更多信息，请查看 <a href=\"https://opsive.com/support/documentation/behavior-designer/variables/\"> variables </a>主题。tasks （任务） 面板列出了您可以使用的所有可能任务。此列表与右键单击并添加任务时找到的列表相同。此列表是通过搜索从 action、composite、conditional 或 decorator 任务类型派生的任何类来创建的。最后一个面板（行为面板）显示您在首次创建行为树时添加的 Behavior Tree （行为树） 组件的检查器。有关每个选项的作用的更多详细信息，请参阅  <a href=\"https://opsive.com/support/documentation/behavior-designer/behavior-tree-component/\"> Behavior Component Overview </a>（行为组件概述） 页面。\n                <img src=\"source/images/s007.png\">\n                Behavior Designer （行为设计器） 窗口中的最后一部分是 operations （作） 工具栏。作工具栏主要用于选择行为树以及添加/删除行为树。标记了以下作：\n                <ul>\n                    <li>标签 1：在您打开的行为树之间向后/向前导航</li>\n                    <li>标签 2：列出场景或项目（包括预制件）中的所有行为树。</li>\n                    <li>标签 3：列出场景中添加了行为树组件的任何游戏对象。</li>\n                    <li>标签 4：列出附加到从标签 3 中选择的游戏对象的任何行为树。</li>\n                    <li>标签 5：列出当前行为树引用的任何外部行为树</li>\n                    <li>标签 6: 移除当前选定的行为树</li>\n                    <li>标签 7：向游戏对象添加新的行为树。</li>\n                    <li>标签 8：保持当前行为树处于活动状态，即使您在层次结构或项目窗口中选择了不同的游戏对象</li>\n                    <li>标签 9：将行为树导出到外部行为树资源。</li>\n                    <li>标签 10：打开可以搜索您的行为树的 find 对话框</li>\n                    <li>标签 11：截取当前行为树的屏幕截图</li>\n                    <li>标签 12：显示 Behavior Designer 首选项。</li>\n                </ul>\n\n            "
    },
    {
        "title": "什么是行为树？",
        "content": "\n            行为树是许多游戏中常用的一种 AI 技术。Halo 2 是第一款使用行为树的主流游戏，在发布了如何在 Halo 2 中使用行为树的详<a href=\"http://www.gamasutra.com/view/feature/130663/gdc_2005_proceeding_handling_.php\">细说明后</a>，它们开始变得更加流行。行为树是许多不同 AI 技术的组合：分层状态机、调度、规划和作执行。它们的主要优点之一是它们易于理解，并且可以使用可视化编辑器创建.\n            <img src=\"source/images/s008.png\">\n            在最简单的级别上，行为树是任务的集合。有四种不同类型的任务：作、条件、复合和装饰器。动作任务可能是最容易理解的，因为它们以某种方式改变了游戏的状态。条件任务测试游戏的某些属性。例如，在上面的树中，AI 代理有两个条件任务和两个作任务。前两个条件任务检查代理的视线范围内是否有敌人，然后确保代理有足够的子弹来发射他的武器。如果这两个条件都成立，则将运行两个作任务。其中一个作任务射击武器，另一个任务播放射击动画。当您形成不同的子树时，行为树的真正力量就会发挥作用。这两个射击动作可以形成一个子树。如果前面的条件任务之一失败，则可以创建另一个子树，该子树执行一组不同的作任务，例如逃离敌人。您可以将子树彼此组合在一起，以形成高级行为。\n\n            复合任务是包含子任务列表的父任务。在上面的示例中，复合任务被标记为 sequence 和 parallel。序列任务将每个任务运行一次，直到所有任务都已运行完毕。它首先运行条件任务，检查是否有敌人在视线范围内。如果敌人在视线范围内，它将运行条件任务，检查代理是否还有子弹。如果代理有足够的子弹，则将运行并行任务，以射击武器并播放射击动画。序列任务一次执行一个子任务，而并行任务同时执行其所有子任务。\n\n            最后一种任务类型是装饰器任务。装饰器任务是一个父任务，它只能有一个子任务。它的功能是以某种方式修改子任务的行为。在上面的例子中，我们没有使用装饰器任务，但如果你想阻止一个任务过早运行（称为中断任务），你可能需要使用它。例如，一个代理可能正在执行诸如收集资源之类的任务。然后，它可以有一个中断任务，如果附近有敌人，就会停止收集资源。另一个装饰器任务的例子是，它会重复运行其子任务x次，或者一个装饰器任务会一直运行子任务，直到它成功完成。\n\n            到目前为止，我们遗漏的主要行为树主题之一是任务的返回状态。您可能有一个任务需要多个帧才能完成。例如，大多数动画不会在一帧内开始和结束。此外，条件任务需要一种方法来告诉其父任务条件是否为 true，以便父任务可以决定是否应继续运行其子任务。这两个问题都可以使用 task status 来解决。任务处于以下三种不同状态之一：正在运行、成功或失败。在第一个示例中，只要拍摄动画正在播放，拍摄动画任务的任务状态就为 running。确定敌人是否在视线范围内的条件任务将在一帧内返回成功或失败。\n\n            Behavior Designer 采用所有这些概念，并将其打包在一个易于使用的界面中，并使用类似于 Unity 的 MonoBehaviour API 的 API。Behavior Designer 在标准安装中包含许多 composite 和 decorator 类。动作和条件任务更特定于游戏，因此包含的任务不多，但<a href=\"https://opsive.com/integrations/?pid=803\">示例项目</a>中有许多示例。可以通过从其中一个任务类型<a href=\"https://opsive.com/support/documentation/behavior-designer/writing-a-new-conditional-task/\">扩展</a>来创建新任务。此外，还制作了许多<a href=\"https://opsive.com/support/documentation/behavior-designer/videos/\">视频</a>，以尽可能轻松地学习 Behavior Designer。  \n\n            "
    },
    {
        "title": "行为树或有限状态机",
        "content": "\n            在什么情况下，您会在有限状态机（例如 Playmaker）上使用行为树？在最高级别，行为树用于 AI，而有限状态机 （FSM） 用于更通用的可视化编程。虽然您可以将行为树用于一般的可视化编程，将有限状态机用于 AI，但这并不是每个工具的设计目的。根据一些人的说法，<a href=\"http://aigamedev.com/open/article/fsm-age-is-over/\">有限状态机</a>的时代已经结束。我们不会走那么远，但在 AI 方面，行为树肯定比有限状态机有其优势。\n\n            与 FSM 相比，行为树有一些优点：它们提供了很大的灵活性，非常强大，并且真的很容易进行更改。\n\n            让我们首先看一下第一个优势：灵活性。使用 FSM，您如何同时运行两个不同的状态？唯一的方法是创建两个单独的 FSM。使用行为树，您需要做的就是添加并行任务，然后就完成了 – 所有子任务都将并行运行。使用行为设计器，这些子任务可以是 PlayMaker FSM，并且这些 FSM 将并行运行。\n\n            灵活性的另一个示例是 Task Guard 任务。在此示例中，您有两个不同的任务来播放声音效果。这两个不同的任务位于行为树的两个不同分支中，因此它们彼此不了解，并且可能会同时播放声音效果。你不希望这种情况发生，因为它听起来不太好。在这种情况下，您可以添加一个信号量任务（在 Behavior Designer 中称为 Task Guard），它一次只允许播放一个音效。当第一个声音播放完毕时，第二个声音将开始播放。\n\n            行为树的另一个优点是它们功能强大。这并不是说有限状态机不强大，只是它们在不同的方面强大。我们认为，与有限状态机相比，行为树使你的人工智能更容易对当前游戏状态做出反应。创建一个能够对各种情况做出反应的行为树更容易，而要使用有限状态机实现类似的人工智能，则需要大量的状态和转换。为了用有限状态机达到相同的结果，你最终会得到一个“<a href=\"https://answers.unrealengine.com/storage/temp/23368-statemachinespaghetti.png\">意大利面条式</a>”的状态机。\n\n            行为树的最后一个优点是它们真的很容易进行更改。行为树如此受欢迎的原因之一是因为它们很容易使用可视化编辑器创建。如果要使用 FSM 更改状态执行顺序，则必须更改状态之间的转换。使用行为树，您只需拖动任务即可。您不必担心过渡。此外，只需更改任务或向任务分支添加新的父任务，即可完全改变 AI 对不同情况的反应方式，这真的很容易。\n\n            话虽如此，行为树和 FSM 不必是互斥的。行为树可以描述 AI 的流程，而 FSM 可以描述函数。这种组合为您提供了行为树的强大功能，同时仍然具有 FSM 的功能。\n            "
    },
    {
        "title": "安装",
        "content": "\n            导入 Behavior Designer 后，您可以从 Tools （工具） 工具栏访问它。您可以通过导入位于 <a href=\"https://opsive.com/downloads/?pid=803\">Downloads</a> 页面上的 Runtime Source Code 包来访问运行时源代码。<strong>在解压此包之前，请确保已删除 Behavior Designer 文件夹，否则将出现编译错误。</strong>\n\n            为了编译通用 Windows 平台 （UWP） 的行为设计器，您必须使用运行时源代码而不是编译的 DLL。无需更改编译设置 – 行为设计器可以在启用 .Net Core 的情况下进行编译。\n\n            当您尝试运行 UWP 应用程序时，可能会收到一个错误，指示找不到任务。为了解决这个问题，TaskUtility.GetTypesWithinAssembly（在 TaskUtility.cs 中）中的以下行应从：\n            <pre><code class=\"language-csharp  line-numbers\">\nloadedAssemblies = GetStorageFileAssemblies(typeName).Result;\n            </code></pre>\n            更改结果至：\n            <pre><code class=\"language-csharp  line-numbers\">\n loadedAssemblies = new List();\n loadedAssemblies.Add(\"Assembly-CSharp\");\n            </code></pre>\n            这将允许在应用程序中找到 Unity 的 C# 程序集。\n            如果使用 IL2CPP 生成项目，则可能会收到与找不到 Default Constructor 相关的 MissingMethodException。这可以通过执行以下作之一来修复：\n            1. 导入运行时源包。\n            2. 将剥离级别更改为低。\n            3 .将缺少的类添加到 link.xml 文件。\n            "
    },
    {
        "title": "行为树组件",
        "content": "\n            <img src=\"source/images/s009.png\"\">\n            行为树组件存储您的行为树，并充当 Behavior Designer 和任务之间的接口。公开了以下 API 以启动和停止您的行为树：\n            <pre><code class=\"language-csharp  line-numbers\">\n public void EnableBehavior();\n // pause:  temporarily stop the behavior tree at its current execution\n point. It can be resumed with EnableBehavior.\n public void DisableBehavior(bool pause = false);\n            </code></pre>\n            您可以使用以下方法之一查找任务：\n             <pre><code class=\"language-csharp  line-numbers\">\nTaskType FindTask<TaskType>();\nList<TaskType> FindTasks<TaskType>();\nTask FindTaskWithName(string taskName);\nList<Task> FindTasksWithName(string taskName);\n            </code></pre>\n            可以通过调用来获取树的当前执行状态：\n            <code class=\"language-csharp  line-numbers\">\nbehaviorTree.ExecutionStatus\n            </code>\n            当树正在运行时，将返回 Running 状态。当树完成时，执行状态将为 Success 或 Failure，具体取决于任务结果。\n\n            还可以订阅以下事件：\n             <pre><code class=\"language-csharp  line-numbers\">\nOnBehaviorStart\nOnBehaviorRestart\nOnBehaviorEnd\n            </code></pre>\n            行为树组件具有以下属性：\n\n            <strong>Behavior Name</strong>\n            行为树的名称。\n\n            <strong>Behavior Description</strong>\n            描述行为树的作用。\n\n            <strong>External Behavior</strong>\n            一个字段，用于指定此行为树启动时应运行的外部行为树。\n\n            <strong>Group</strong>\n            行为树的数字分组。可用于轻松查找行为树。CTF 示例项目显示了一个示例。\n\n            <strong>Start When Enabled</strong>\n            如果为 true，则当组件启用时，行为树将开始运行。\n\n            <strong>Asynchronous Load</strong>\n            指定行为树是否应在单独的线程中加载。由于 Unity 不允许在工作线程上进行 API 调用，因此，如果对<a href=\"https://opsive.com/support/documentation/behavior-designer/variables/\">共享变量</a>使用属性映射，则应禁用此选项。\n\n            <strong>Pause When Disabled</strong>\n            如果为 true，则当组件被禁用时，行为树将暂停。如果为 false，则行为树将结束\n\n            <strong>Restart When Complete</strong>\n            如果为 true，则行为树将在完成执行后从头开始重新启动。如果为 false，则行为树将结束。\n\n            <strong>Reset Values On Restart</strong>\n            如果为 true，则当树重新启动时，变量和任务公共变量将重置为其原始值。\n\n            <strong> Log Task Changes</strong>\n            用于调试。如果启用，则行为树将在任务状态更改（例如启动或停止）时输出。\n\n            "
    },
    {
        "title": "从脚本创建行为树",
        "content": "\n            在某些情况下，您可能希望从脚本创建行为树，而不是直接依赖预制件来包含行为树。例如，您可能已经保存了一个<a href=\"https://opsive.com/support/documentation/behavior-designer/external-behavior-trees/\">外部行为树</a>，并希望从新创建的行为树中加载该树。这可以通过在行为树组件上设置 externalBehavior 变量来实现：\n            <pre><code class=\"language-csharp  line-numbers\">\nusing UnityEngine;\nusing BehaviorDesigner.Runtime;\npublic class CreateTree : MonoBehaviour\n{\n    public ExternalBehaviorTree behaviorTree;\n    private void Start()\n    {\n            var bt = gameObject.AddComponent<BehaviorTree>();\n            bt.StartWhenEnabled = false;\n            bt.ExternalBehavior = behaviorTree;\n    }\n}\n            </code></pre>\n            在此示例中，公共变量 behaviorTree 包含对外部行为树的引用。当新创建的树加载时，它将为其所有任务加载外部行为树。为了防止树立即运行，我们将 StartWhenEnabled 设置为 false。然后可以使用 bt 手动启动树。EnableBehavior（） 的 EnableBehavior（） 中。\n\n\n        \n        "
    },
    {
        "title": "行为管理器",
        "content": "\n        <img src=\"source/images/s010.png\">\n        当行为树运行时，它会创建一个带有 Behavior Manager 组件的新游戏对象（如果尚未创建）。此组件管理场景中所有行为树的执行。\n        您可以通过更改 update interval 属性来控制行为树的时钟周期。“Every Frame” 将在 Update 循环中的每一帧更新行为树。“Specify Seconds” 允许您将行为树勾选给定的秒数。最后一个选项是 “Manual（手动）”，它可以让您控制何时更新行为树。您可以通过调用 tick 来更新行为树：\n        <code class=\"language-csharp  line-numbers\">BehaviorManager.instance.Tick();</code>\n        此外，如果您希望每个行为树都有自己的 tick rate，您可以使用以下命令手动更新每个行为树：\n        <code class=\"language-csharp  line-numbers\">BehaviorManager.instance.Tick(BehaviorTree)</code>\n        Task Execution Type 允许您指定行为树是否应继续执行任务，直到在该 tick 期间命中已执行的任务，或者是否应继续执行任务，直到在该 tick 期间执行了最大数量的任务。例如，请考虑以下行为树：\n        <img src=\"source/images/s011.png\">\n        Repeater 任务设置为重复 5 次。如果 Task Execute Type 设置为 No Duplicates，则 Play Sound 任务将在单个更新期间仅执行一次。如果 Task Execution Type （任务执行类型） 设置为 Count （计数），则可以指定最大任务执行计数。如果指定了值 5，则 Play Sound 任务将在单个时钟周期中执行所有 5 次。\n\n        "
    },
    {
        "title": "任务",
        "content": "\n        在最高级别，行为树是任务的集合。任务具有与 Unity 的 MonoBehaviour 类似的 API，因此开始<a href=\"https://opsive.com/support/documentation/behavior-designer/writing-a-new-conditional-task/\">编写自己的任务</a>应该非常容易。task 类具有以下 API：\n        <pre><code class=\"language-csharp  line-numbers\">\n// OnAwake is called once when the behavior tree is enabled. Think of\n it as a constructor.\n void OnAwake();\n // OnStart is called immediately before execution. It is used to setup\n any variables that need to be reset from the previous run.\n void OnStart();\n // OnUpdate runs the actual task.\n TaskStatus OnUpdate();\n // OnFixedUpdate executes during the FixedUpdate loop. The TaskStatus\n must be returned within OnUpdate.\n void OnFixedUpdate();\n // OnEnd is called after execution on a success or failure.\n void OnEnd();\n // OnPause is called when the behavior is paused or resumed.\n void OnPause(bool paused);\n // Returns the priority of the task, used by the Priority Selector.\n float GetPriority();\n // Returns the utility of the task, used by the Utility Selector for\n Utility Theory.\n float GetUtility();\n // OnBehaviorComplete is called after the behavior tree finishes\n executing.\n void OnBehaviorComplete();\n // OnReset is called by the inspector to reset the public properties\n void OnReset();\n // Allow OnDrawGizmos to be called from the tasks.\n void OnDrawGizmos();\n // Keep a reference to the behavior that owns this task.\n Behavior Owner;\n        </code></pre>\n        任务具有三个公开的属性：name、comment 和 instant。Instant 是唯一一个在它的作用中不明显的属性。当任务返回成功或失败时，它会立即移动到同一更新刻度内的下一个任务。如果您取消选中即时任务，它现在将等待更新滴答，然后再执行下一个任务。这是限制行为树的一种简单方法。\n\n        执行任务时使用以程图：\n        <img src=\"source/images/s012.png\">\n\n        "
    },
    {
        "title": "父任务(Parent Tasks)",
        "content": "\n        Parent Tasks （父任务） 是行为树中的复合任务和装饰器任务。虽然 ParentTask API 没有与 Unity 的 MonoBehaviour 类等效的 API，但仍然很容易确定每个方法的用途。\n        <pre><code class=\"language-csharp  line-numbers\">\n // The maximum number of children a parent task can have. Will usually\n be 1 or int.MaxValue\n public virtual int MaxChildren();\n // Boolean value to determine if the current task is a parallel task.\n public virtual bool CanRunParallelChildren();\n // The index of the currently active child.\n public virtual int CurrentChildIndex();\n // Boolean value to determine if the current task can execute.\n public virtual bool CanExecute();\n // Apply a decorator to the executed status.\n public virtual TaskStatus Decorate(TaskStatus status);\n // Notifies the parent task that the child has been executed and has a\n status of childStatus.\n public virtual void OnChildExecuted(TaskStatus childStatus);\n // Notifies the parent task that the child at index childIndex has\n been executed and has a status of childStatus.\n public virtual void OnChildExecuted(int childIndex, TaskStatus\n childStatus);\n // Notifies the task that the child has started to run.\n public virtual void OnChildStarted();\n // Notifies the parallel task that the child at index childIndex has\n started to run.\n public virtual void OnChildStarted(int childIndex);\n // Some parent tasks need to be able to override the status, such as\n parallel tasks.\n public virtual TaskStatus OverrideStatus(TaskStatus status);\n // The interrupt node will override the status if it has been\n interrupted.\n public virtual TaskStatus OverrideStatus();\n // Notifies the composite task that an conditional abort has been\n triggered and the child index should reset.\n public virtual void OnConditionalAbort(int childIndex);\n        </code></pre>\n        \n        "
    },
    {
        "title": "编写新的条件任务",
        "content": "\n        本主题分为两个部分。第一部分介绍如何编写新的条件任务，第二部分（<a href=\"https://opsive.com/support/documentation/behavior-designer/writing-a-new-action-task/\">可在此处获取</a>）介绍如何编写新的作任务。条件任务将确定是否有任何对象在视线范围内，并且 action 类将朝向视线范围内的对象。我们还将对这两项任务使用<a href=\"https://opsive.com/support/documentation/behavior-designer/variables/\">变量</a>。我们还录制了一段关于这个主题的视频，可以在 <a href=\"https://www.youtube.com/watch?v=q58ELfkyjQk\">YouTube</a> 上找到。\n\n        我们将编写的第一个任务是 Within Sight 任务。由于此任务不会更改游戏状态，而只是检查游戏状态，因此此任务将从 Conditional 任务派生。确保您包含 BehaviorDesigner.Runtime.Tasks 命名空间：\n        <pre><code class=\"language-csharp  line-numbers\">\nusing UnityEngine;\nusing BehaviorDesigner.Runtime.Tasks;\npublic class WithinSight : Conditional\n{\n} \n        </code></pre>\n        我们现在需要创建三个公共变量和一个私有变量：\n        <pre><code class=\"language-csharp  line-numbers\">\nusing UnityEngine;\nusing BehaviorDesigner.Runtime;\nusing BehaviorDesigner.Runtime.Tasks;\npublic class WithinSight : Conditional\n{\n    public float fieldOfViewAngle;\n    public string targetTag;\n    public SharedTransform target;\n    private Transform[] possibleTargets;\n}\n        </code></pre>\n        视野角度是物体可以看到的视野。Target tag 是对象可以移动到的目标的标签。Target 是一个共享变量，将由 Within Sight 和 Move Towards 任务使用。如果您使用的是共享变量，请确保包含 BehaviorDesigner.Runtime 命名空间。最后一个变量 possible targets 是带有 target 标签的所有 Transform 的缓存。如果您查看任务 API，您可以看到我们可以在 OnAwake 或 OnStart 方法中创建该缓存。由于可能的转换列表不会随着 Within Sight 任务的启用/禁用而更改，因此我们将在 OnAwake 中执行缓存：\n        <pre><code class=\"language-csharp  line-numbers\">\npublic override void OnAwake()\n{\n    var targets = GameObject.FindGameObjectsWithTag(targetTag);\n    possibleTargets = new Transform[targets.Length];\n    for (int i = 0; i < targets.Length; ++i) {\n        possibleTargets[i] = targets[i].transform;\n    }\n}\n        </code></pre>\n        此 OnAwake 方法将查找具有 target 标记的所有游戏对象，然后循环遍历它们，并在可能的 targets 数组中缓存其转换。然后，重写的 OnUpdate 方法使用可能的目标数组：\n        <pre><code class=\"language-csharp  line-numbers\">\npublic override TaskStatus OnUpdate()\n{\n    for (int i = 0; i < possibleTargets.Length; ++i) {\n        if (WithinSight(possibleTargets[i], fieldOfViewAngle)) {\n        target.Value = possibleTargets[i];\n        return TaskStatus.Success;\n        }\n    }\n    return TaskStatus.Failure;\n}\n        </code></pre>\n        每次更新任务时，它都会检查是否有任何可能的目标在视线范围内。如果一个目标在视线范围内，它将设置目标值并返回 success。设置此目标值是关键，因为这样 Move Towards 任务就可以知道要移动的方向。如果视线范围内没有目标，则任务将返回 failure。此任务的最后一部分是 WithinSight 方法：\n        <pre><code class=\"language-csharp  line-numbers\">\npublic bool WithinSight(Transform targetTransform, float fieldOfViewAngle)\n{\n    Vector3 direction = targetTransform.position - transform.position;\n    return Vector3.Angle(direction, transform.forward) < fieldOfViewAngle;\n}\n        </code></pre>\n        此方法首先获取当前转换和目标转换之间的方向向量。然后，它将计算方向矢量和当前正向矢量之间的角度以确定角度。如果该角度小于 Field of view angle，则目标变换位于当前 Transform 的视线范围内。\n\n        这就是 Within Sight 任务的全部内容。下面是完整任务的样子：\n        <pre><code class=\"language-csharp  line-numbers\">\nusing UnityEngine;\nusing BehaviorDesigner.Runtime;\nusing BehaviorDesigner.Runtime.Tasks;\npublic class WithinSight : Conditional\n{\n    // How wide of an angle the object can see\n    public float fieldOfViewAngle;\n    // The tag of the targets\n    public string targetTag;\n    // Set the target variable when a target has been found so the subsequent tasks know which object is the target\n    public SharedTransform target;\n    // A cache of all of the possible targets\n    private Transform[] possibleTargets;\n    public override void OnAwake()\n    {\n        // Cache all of the transforms that have a tag of targetTag\n        var targets = GameObject.FindGameObjectsWithTag(targetTag);\n        possibleTargets = new Transform[targets.Length];\n        for (int i = 0; i < targets.Length; ++i)\n        {\n            possibleTargets[i] = targets[i].transform;\n        }\n    }\n    public override TaskStatus OnUpdate()\n    {\n        // Return success if a target is within sight\n        for (int i = 0; i < possibleTargets.Length; ++i)\n        {\n            if (WithinSight(possibleTargets[i], fieldOfViewAngle))\n            {\n                // Set the target so other tasks will know which transform is within sight\n                target.Value = possibleTargets[i];\n                return TaskStatus.Success;\n            }\n        }\n        return TaskStatus.Failure;\n    }\n    // Returns true if targetTransform is within sight of current transform\n    public bool WithinSight(Transform targetTransform, float fieldOfViewAngle)\n    {\n        Vector3 direction = targetTransform.position - transform.position;\n        // An object is within sight if the angle is less than field of view\n        return Vector3.Angle(direction, transform.forward) < fieldOfViewAngle;\n    }\n}</code></pre>\n        继续阅读本主题的第二部分，编写 <a href=\"https://opsive.com/support/documentation/behavior-designer/writing-a-new-action-task/\">Move Towards</a> 任务。\n        "
    }
]
